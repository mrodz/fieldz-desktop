use core::str;
use std::{
    borrow::Cow,
    collections::BTreeMap,
    fmt::Display,
    ops::Deref,
    time::{SystemTime, UNIX_EPOCH},
};

use base64::Engine;
use rand::{distributions::Alphanumeric, Rng};
use serde::{Deserialize, Serialize};
use thiserror::Error;

#[derive(Error, Clone, Debug, PartialEq)]
pub enum TwitterOAuthError {
    #[error(transparent)]
    Base64EncodingError(#[from] base64::EncodeSliceError),
    #[error(transparent)]
    DecodeUtf8Error(#[from] std::string::FromUtf8Error),
    #[error(transparent)]
    Utf8Error(#[from] std::str::Utf8Error),
    #[error(
        "The Twitter OAuth client does not support a `reqwest::Request` whose body is a stream"
    )]
    RequestBodyIsStream,
    #[error(transparent)]
    DeserializationError(#[from] serde::de::value::Error),
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TwitterOAuthAuthorizationMetadata {
    oauth_consumer_key: String,
    oauth_nonce: String,
    oauth_timestamp: u64,
    oauth_version: String,
    oauth_token: Option<String>,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct TwitterOAuthSignature {
    oauth_signature: String,
    oauth_signature_method: String,
}

#[derive(Debug)]
pub struct TwitterOAuthAuthorization {
    metadata: TwitterOAuthAuthorizationMetadata,
    signature: TwitterOAuthSignature,
}

#[derive(Debug)]
pub struct TwitterRequest {
    api: reqwest::Request,
    authorization: TwitterOAuthAuthorization,
}

impl Deref for TwitterRequest {
    type Target = reqwest::Request;

    fn deref(&self) -> &Self::Target {
        &self.api
    }
}

impl TwitterRequest {
    pub fn new(
        request: reqwest::Request,
        oauth_consumer_key: impl AsRef<str>,
    ) -> Result<Self, TwitterOAuthError> {
        let metadata = TwitterOAuthAuthorizationMetadata::new(oauth_consumer_key)?;

        todo!()
        // Self {
        //     api: request,

        // }
    }
}

/// The value for this request was generated by base64 encoding 32 bytes
/// of random data, and stripping out all non-word characters, but any
/// approach which produces a relatively random alphanumeric string should
/// be OK here.
pub fn generate_twitter_compliant_nonce() -> Result<String, TwitterOAuthError> {
    let mut rng = rand::thread_rng();

    let mut nonce: [u8; 32] = std::array::from_fn(|_| rng.sample(Alphanumeric));

    // 4 * ceil(32 / 3)
    let mut output_buf = [0; 44];

    base64::prelude::BASE64_URL_SAFE.encode_slice(&nonce, &mut output_buf)?;

    Ok(str::from_utf8(&output_buf).map(str::to_owned)?)
}

pub const TWITTER_OAUTH_SIGNATURE_METHOD: &str = "HMAC-SHA1";
pub const TWITTER_OAUTH_VERSION: &str = "1.0";

impl TwitterOAuthAuthorizationMetadata {
    pub fn new(oauth_consumer_key: impl AsRef<str>) -> Result<Self, TwitterOAuthError> {
        let oauth_nonce = generate_twitter_compliant_nonce()?;

        let start = SystemTime::now();
        let since_the_epoch = start
            .duration_since(UNIX_EPOCH)
            .expect("Time went backwards");

        let oauth_timestamp = since_the_epoch.as_secs();

        todo!()
        // Ok(Self {
        //     oauth_consumer_key: oauth_consumer_key.as_ref().into(),
        //     oauth_nonce,
        //     oauth_timestamp,
        //     oauth_version: TWITTER_OAUTH_VERSION.into(),
        // })
    }
}

struct ParametersPipeline<'a> {
    metadata: &'a TwitterOAuthAuthorizationMetadata,
    request: &'a reqwest::Request,
    data: BTreeMap<Cow<'a, str>, String>,
}

impl<'a> ParametersPipeline<'a> {
    fn new(
        metadata: &'a TwitterOAuthAuthorizationMetadata,
        request: &'a reqwest::Request,
        oauth_signature_method: impl AsRef<str>,
    ) -> Result<Self, TwitterOAuthError> {
        let mut result = BTreeMap::new();

        result.insert(
            Cow::Borrowed("oauth_consumer_key"),
            urlencoding::decode(&metadata.oauth_consumer_key)?.into_owned(),
        );
        result.insert(
            Cow::Borrowed("oauth_nonce"),
            urlencoding::decode(&metadata.oauth_nonce)?.into_owned(),
        );
        result.insert(
            Cow::Borrowed("oauth_signature_method"),
            urlencoding::decode(oauth_signature_method.as_ref())?.into_owned(),
        );
        result.insert(
            Cow::Borrowed("oauth_timestamp"),
            metadata.oauth_timestamp.to_string(),
        );

        if let Some(ref oauth_token) = metadata.oauth_token {
            result.insert(
                Cow::Borrowed("oauth_token"),
                urlencoding::decode(&oauth_token)?.into_owned(),
            );
        }

        result.insert(
            Cow::Borrowed("oauth_version"),
            urlencoding::decode(&metadata.oauth_version)?.into_owned(),
        );

        for (param, value) in request.url().query_pairs() {
            result.insert(param, urlencoding::decode(value.as_ref())?.into_owned());
        }

        if let Some(body) = request.body() {
            let Some(body_bytes) = body.as_bytes() else {
                return Err(TwitterOAuthError::RequestBodyIsStream);
            };

            let body_map = serde_urlencoded::from_bytes::<Vec<(String, String)>>(body_bytes)?;

            for (param, value) in body_map {
                result.insert(
                    Cow::Owned(urlencoding::decode(&param)?.into_owned()),
                    urlencoding::decode(&value)?.into_owned(),
                );
            }
        }

        let mut raw = Self {
            metadata,
            request,
            data: result,
        };

        raw.percent_encode_kv();

        Ok(raw)
    }

    fn percent_encode_kv(&mut self) {
        let mut encoded = BTreeMap::new();

        for (key, value) in &self.data {
            let encoded_key = urlencoding::encode(key.as_ref());
            let encoded_value = urlencoding::encode(value.as_ref());

            encoded.insert(
                Cow::Owned(encoded_key.into_owned()),
                encoded_value.into_owned(),
            );
        }

        self.data = encoded;
    }
}

impl<'a> Display for ParametersPipeline<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut iterator = self.data.iter();

        let Some((first_encoded_key, first_encoded_value)) = iterator.next() else {
            return Ok(());
        };

        write!(f, "{first_encoded_key}={first_encoded_value}")?;

        for (encoded_key, encoded_value) in iterator {
            write!(f, "&{encoded_key}={encoded_value}")?;
        }

        Ok(())
    }
}

impl TwitterOAuthSignature {
    pub fn new(
        metadata: &TwitterOAuthAuthorizationMetadata,
        request: &reqwest::Request,
        oauth_signature_method: impl AsRef<str>,
    ) -> Result<Self, TwitterOAuthError> {
        let method = request.method().as_str();

        let mut base_url = request.url().clone();
        base_url.set_query(None);
        base_url.set_fragment(None);

        let parameters = ParametersPipeline::new(metadata, request, oauth_signature_method)?;

        let parameter_string = parameters.to_string();

        

        todo!()
        // Self {

        // }
    }
}
